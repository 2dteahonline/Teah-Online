<!DOCTYPE html>
<html>
<head>
  <title>Graal-Style PvP Arena</title>
  <style>
    * { margin: 0; padding: 0; }
    body { background: #000; overflow: hidden; }
    canvas { display: block; image-rendering: pixelated; image-rendering: crisp-edges; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d", { alpha: false });

    const BASE_W = 1920, BASE_H = 1080;
    let scale = 1;

    function resize() {
      scale = Math.min(window.innerWidth / BASE_W, window.innerHeight / BASE_H);
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.round(BASE_W * dpr);
      canvas.height = Math.round(BASE_H * dpr);
      canvas.style.width = (BASE_W * scale) + "px";
      canvas.style.height = (BASE_H * scale) + "px";
      canvas.style.marginLeft = ((window.innerWidth - BASE_W * scale) / 2) + "px";
      canvas.style.marginTop = ((window.innerHeight - BASE_H * scale) / 2) + "px";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      // Crisp pixel rendering
      ctx.imageSmoothingEnabled = false;
      ctx.textRendering = "geometricPrecision";
    }
    resize();
    window.addEventListener("resize", resize);
  </script>

  <!-- Phase A: Shared data -->
  <script src="js/shared/levelData.js"></script>
  <script src="js/shared/mobTypes.js"></script>
  <script src="js/shared/itemData.js"></script>
  <script src="js/shared/oreData.js"></script>
  <script src="js/shared/cookingData.js"></script>

  <!-- Phase B: Authority systems -->
  <script src="js/authority/eventBus.js"></script>
  <script src="js/authority/gameState.js"></script>
  <script src="js/authority/combatSystem.js"></script>

  <!-- Phase C: Client rendering -->
  <script src="js/client/rendering/hitEffects.js"></script>
  <script src="js/client/rendering/entityRenderers.js"></script>

  <script>
    // ---- ACTIVE LEVEL STATE ----
    let level = null;
    let collisionGrid = null;
    let levelEntities = null;
    let MAP_W = 0, MAP_H = 0;
    let placedTiles = []; // early declaration for setLevel access

    function setLevel(levelObj) {
      level = levelObj;
      collisionGrid = collisionFromAscii(level.collisionAscii);
      levelEntities = level.entities || [];
      MAP_W = level.widthTiles * TILE;
      MAP_H = level.heightTiles * TILE;
      placedTiles.length = 0;
      Scene._update();
    }

    // ===================== SCENE STATE MACHINE =====================
    // Replaces 24+ scattered level.isLobby / level.isCave checks.
    // Scene.is('dungeon')  Scene.inDungeon  Scene.current
    const Scene = {
      _current: 'lobby', // 'lobby', 'cave', 'dungeon'

      _update() {
        const prev = this._current;
        if (!level) { this._current = 'lobby'; return; }
        if (level.isLobby) this._current = 'lobby';
        else if (level.isCave) this._current = 'cave';
        else if (level.isMine) this._current = 'mine';
        else if (level.isCooking) this._current = 'cooking';
        else this._current = 'dungeon';
        if (prev !== this._current) {
          try { Events.emit('scene_changed', { from: prev, to: this._current }); } catch(e) {}
        }
      },

      is(scene) { return this._current === scene; },
      get current() { return this._current; },
      get inDungeon() { return this._current === 'dungeon'; },
      get inLobby() { return this._current === 'lobby'; },
      get inCave() { return this._current === 'cave'; },
      get inMine() { return this._current === 'mine'; },
      get inCooking() { return this._current === 'cooking'; },
    };

    // ---- ZONE TRANSITIONS ----
    let transitioning = false;
    let transitionAlpha = 0;
    let transitionPhase = 0;
    let transitionTarget = null;
    let transitionSpawnTX = 0;
    let transitionSpawnTY = 0;

    function enterLevel(targetLevelId, spawnTX, spawnTY) {
      try {
        const targetLevel = LEVELS[targetLevelId];
        if (!targetLevel) return;
        setLevel(targetLevel);
        player.x = spawnTX * TILE + TILE / 2;
        player.y = spawnTY * TILE + TILE / 2;
        player.vx = 0; player.vy = 0;
        UI.close();
        mobs.length = 0;
        bullets.length = 0;
        hitEffects.length = 0;
        medpacks.length = 0;
        queueActive = false; queuePlayers = 0; queueTimer = 0;
        if (targetLevel.isLobby || targetLevel.isCave) {
          resetCombatState('lobby');
        } else if (targetLevel.isMine) {
          resetCombatState('mine');
        } else if (targetLevel.isCooking) {
          resetCombatState('cooking');
          if (typeof initDeliNPCs === 'function') initDeliNPCs();
        } else {
          resetCombatState('dungeon');
        }
        transitioning = true;
        transitionPhase = 2;
        transitionAlpha = 1;
      } catch(err) {
        console.error("enterLevel error:", err);
        transitioning = false;
      }
    }

    function startTransition(targetLevelId, spawnTX, spawnTY) {
      if (transitioning) return;
      transitionTarget = targetLevelId;
      transitionSpawnTX = spawnTX;
      transitionSpawnTY = spawnTY;
      transitioning = true;
      transitionPhase = 1;
      transitionAlpha = 0;
    }

    function updateTransition() {
      if (!transitioning) return;
      if (transitionPhase === 1) {
        transitionAlpha += 0.12;
        if (transitionAlpha >= 1) {
          transitionAlpha = 1;
          transitionPhase = 0;
          transitioning = false;
          enterLevel(transitionTarget, transitionSpawnTX, transitionSpawnTY);
        }
      } else if (transitionPhase === 2) {
        transitionAlpha -= 0.08;
        if (transitionAlpha <= 0) {
          transitionAlpha = 0;
          transitioning = false;
          transitionPhase = 0;
        }
      }
    }

    // ---- QUEUE SYSTEM ----
    let queueActive = false;
    let queueTimer = 0;
    const QUEUE_DURATION = 600;
    let queuePlayers = 0;
    const QUEUE_MAX = 4;
    let queueDungeonId = '';
    let queueSpawnTX = 0;
    let queueSpawnTY = 0;
    let nearQueue = false;
    let nearStairs = false;
    let queueLockX = 0;
    let queueLockY = 0;
    let queueCirclePositions = []; // world positions of the 4 sigils

    function checkPortals() {
      if (transitioning) return;
      nearQueue = false;
      for (const e of levelEntities) {
        const ew = e.w || 1, eh = e.h || 1;
        const px = player.x / TILE, py = player.y / TILE;
        const inZone = px >= e.tx && px < e.tx + ew && py >= e.ty && py < e.ty + eh;
        if (e.type === 'cave_entrance' && Scene.inLobby && inZone) {
          startTransition(e.target, e.spawnTX, e.spawnTY);
          return;
        }
        if (e.type === 'mine_entrance' && Scene.inLobby && inZone) {
          startTransition(e.target, e.spawnTX, e.spawnTY);
          return;
        }
        if (e.type === 'mine_exit' && Scene.inMine && inZone) {
          startTransition(e.target, e.spawnTX, e.spawnTY);
          return;
        }
        if (e.type === 'mine_door' && Scene.inMine && inZone) {
          startTransition(e.target, e.spawnTX, e.spawnTY);
          return;
        }
        if (e.type === 'deli_entrance' && Scene.inLobby && inZone) {
          startTransition(e.target, e.spawnTX, e.spawnTY);
          return;
        }
        if (e.type === 'deli_exit' && Scene.inCooking && inZone) {
          startTransition(e.target, e.spawnTX, e.spawnTY);
          return;
        }
        if (e.type === 'cave_exit' && Scene.inCave && inZone) {
          startTransition(e.target, e.spawnTX, e.spawnTY);
          return;
        }
        if (e.type === 'queue_zone' && Scene.inCave && inZone) {
          nearQueue = true;
          queueDungeonId = e.dungeonId;
          queueSpawnTX = e.spawnTX;
          queueSpawnTY = e.spawnTY;
        }
      }
      // Staircase interaction — dungeon only, stairs must be open, press E to enter
      nearStairs = false;
      if (stairsOpen && Scene.inDungeon) {
        const stairCX = level.widthTiles / 2;
        const stairCY = level.heightTiles / 2;
        const px = player.x / TILE, py = player.y / TILE;
        if (px >= stairCX - 2 && px < stairCX + 2 && py >= stairCY - 2 && py < stairCY + 2) {
          nearStairs = true;
        }
      }
    }

    function goToNextFloor() {
      if (transitioning) return;
      dungeonFloor++;
      resetCombatState('floor');
      // Re-enter same level layout, spawn at center
      player.x = 20 * TILE + TILE / 2;
      player.y = 20 * TILE + TILE / 2;
      player.vx = 0; player.vy = 0;
      // Transition effect
      transitioning = true;
      transitionPhase = 2;
      transitionAlpha = 1;
      hitEffects.push({ x: player.x, y: player.y - 30, life: 30, maxLife: 30, type: "heal", dmg: "FLOOR " + dungeonFloor });
      Events.emit('floor_changed', { floor: dungeonFloor });
    }

    function joinQueue() {
      if (!nearQueue || transitioning) return;
      if (queueActive) {
        queueActive = false;
        queuePlayers = Math.max(0, queuePlayers - 1);
        return;
      }
      if (queuePlayers >= QUEUE_MAX) return;
      queueActive = true;
      queuePlayers = 1;
      queueTimer = QUEUE_DURATION;
      // Snap to first circle position
      if (queueCirclePositions.length > 0) {
        queueLockX = queueCirclePositions[0].x;
        queueLockY = queueCirclePositions[0].y;
      } else {
        queueLockX = player.x;
        queueLockY = player.y;
      }
    }

    function updateQueue() {
      if (!queueActive) return;
      // Lock player in place on their sigil
      player.x = queueLockX;
      player.y = queueLockY;
      player.vx = 0;
      player.vy = 0;
      player.moving = false;
      player.dir = 1; // face up toward dungeon (back facing camera)
      queueTimer--;
      if (queueTimer <= 0) {
        queueActive = false;
        queuePlayers = 0;
        enterLevel(queueDungeonId, queueSpawnTX, queueSpawnTY);
      }
    }

    // ---- COLLISION ----
    function isSolid(col, row) {
      if (!level) return true;
      if (col < 0 || row < 0 || col >= level.widthTiles || row >= level.heightTiles) return true;
      if (collisionGrid[row][col] === 1) return true;
      for (const e of levelEntities) {
        if (!e.solid) continue;
        const w = e.w ?? 1;
        const h = e.h ?? 1;
        if (col >= e.tx && col < e.tx + w && row >= e.ty && row < e.ty + h) return true;
      }
      return false;
    }

    // ---- BACKGROUND RENDERER (placeholder until bg.png) ----
    function drawLevelBackground(camX, camY) {
      ctx.fillStyle = Scene.inCooking ? '#c0b898' : Scene.inMine ? '#1a1510' : Scene.inCave ? '#1a1818' : Scene.inLobby ? '#1a4a18' : '#1e1e26';
      ctx.fillRect(0, 0, BASE_W, BASE_H);

      const startTX = Math.max(0, Math.floor(camX / TILE));
      const startTY = Math.max(0, Math.floor(camY / TILE));
      const endTX = Math.min(level.widthTiles - 1, startTX + Math.ceil(BASE_W / TILE) + 1);
      const endTY = Math.min(level.heightTiles - 1, startTY + Math.ceil(BASE_H / TILE) + 1);

      for (let ty = startTY; ty <= endTY; ty++) {
        for (let tx = startTX; tx <= endTX; tx++) {
          const x = tx * TILE - camX;
          const y = ty * TILE - camY;
          const isBorder = tx === 0 || ty === 0 || tx === level.widthTiles-1 || ty === level.heightTiles-1;

          // === LOBBY TILES ===
          if (Scene.inLobby) {
            const ascii = level.collisionAscii[ty]?.[tx];
            if (ascii === '@') {
              // Hedge border
              ctx.fillStyle = '#1a4a18';
              ctx.fillRect(x, y, TILE, TILE);
              ctx.fillStyle = '#226a20';
              ctx.fillRect(x + 2, y + 2, TILE - 4, TILE - 4);
              for (let li = 0; li < 3; li++) {
                ctx.fillStyle = `rgba(40,120,30,${0.4 + li * 0.1})`;
                ctx.beginPath(); ctx.arc(x + 10 + li * 14, y + 12 + (li % 2) * 18, 8, 0, Math.PI * 2); ctx.fill();
              }
            } else {
              // Grass
              const gv = ((tx * 7 + ty * 13) % 5);
              const gr = 60 + gv * 2, gg = 120 + gv * 3, gb = 45 + gv;
              ctx.fillStyle = `rgb(${gr},${gg},${gb})`;
              ctx.fillRect(x, y, TILE, TILE);
              ctx.strokeStyle = 'rgba(0,0,0,0.03)';
              ctx.lineWidth = 1;
              ctx.strokeRect(x, y, TILE, TILE);
              // Grass blades
              if ((tx + ty * 3) % 4 === 0) {
                ctx.strokeStyle = `rgba(80,150,60,0.3)`;
                ctx.beginPath();
                ctx.moveTo(x + 12, y + TILE - 4); ctx.lineTo(x + 14, y + TILE - 14);
                ctx.moveTo(x + 30, y + TILE - 6); ctx.lineTo(x + 28, y + TILE - 16);
                ctx.stroke();
              }
            }
            continue;
          }

          // === CAVE TILES ===
          if (Scene.inCave) {
            const isOuterEdge = tx === 0 || ty === 0 || tx === level.widthTiles - 1 || ty === level.heightTiles - 1;
            if (collisionGrid[ty][tx] === 1 && isOuterEdge) {
              // Outer border — dark stone wall
              ctx.fillStyle = '#1a1818';
              ctx.fillRect(x, y, TILE, TILE);
              ctx.fillStyle = '#242220';
              ctx.fillRect(x + 2, y + 2, TILE - 4, TILE - 4);
              if ((tx + ty * 5) % 7 === 0) {
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(x + 8, y + 10); ctx.lineTo(x + 20, y + 30); ctx.stroke();
              }
            } else {
              // Gray stone floor — uniform across entire interior
              const sv = ((tx * 3 + ty * 7) % 5);
              ctx.fillStyle = `rgb(${48 + sv * 2},${46 + sv * 2},${52 + sv})`;
              ctx.fillRect(x, y, TILE, TILE);
              ctx.strokeStyle = 'rgba(0,0,0,0.05)';
              ctx.lineWidth = 1;
              ctx.strokeRect(x, y, TILE, TILE);
              if ((tx + ty) % 8 === 0) {
                ctx.fillStyle = 'rgba(80,75,70,0.3)';
                ctx.beginPath(); ctx.arc(x + 20, y + 24, 3, 0, Math.PI * 2); ctx.fill();
              }
            }
            continue;
          }

          // === MINE TILES ===
          if (Scene.inMine) {
            const isOuterEdge = tx === 0 || ty === 0 || tx === level.widthTiles - 1 || ty === level.heightTiles - 1;
            if (collisionGrid[ty][tx] === 1) {
              // Rocky cave wall
              ctx.fillStyle = '#2a2010';
              ctx.fillRect(x, y, TILE, TILE);
              ctx.fillStyle = '#342818';
              ctx.fillRect(x + 2, y + 2, TILE - 4, TILE - 4);
              // Rock texture
              if ((tx + ty * 3) % 5 === 0) {
                ctx.fillStyle = 'rgba(60,50,30,0.4)';
                ctx.beginPath(); ctx.arc(x + 18, y + 14, 6, 0, Math.PI * 2); ctx.fill();
              }
              if ((tx * 7 + ty) % 6 === 0) {
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(x + 6, y + 12); ctx.lineTo(x + 22, y + 28); ctx.stroke();
              }
            } else {
              // Mine floor — earthy brown stone
              const sv = ((tx * 5 + ty * 11) % 5);
              ctx.fillStyle = `rgb(${52 + sv * 2},${44 + sv * 2},${32 + sv})`;
              ctx.fillRect(x, y, TILE, TILE);
              ctx.strokeStyle = 'rgba(0,0,0,0.06)';
              ctx.lineWidth = 1;
              ctx.strokeRect(x, y, TILE, TILE);
              // Occasional pebbles
              if ((tx + ty * 3) % 7 === 0) {
                ctx.fillStyle = 'rgba(70,60,40,0.3)';
                ctx.beginPath(); ctx.arc(x + 16, y + 20, 2, 0, Math.PI * 2); ctx.fill();
              }
              if ((tx * 3 + ty) % 9 === 0) {
                ctx.fillStyle = 'rgba(90,75,50,0.2)';
                ctx.beginPath(); ctx.arc(x + 32, y + 12, 3, 0, Math.PI * 2); ctx.fill();
              }
            }
            continue;
          }

          // === DELI / COOKING TILES ===
          if (Scene.inCooking) {
            if (collisionGrid[ty][tx] === 1) {
              // Deli walls — warm cream/tan
              ctx.fillStyle = '#c8b898';
              ctx.fillRect(x, y, TILE, TILE);
              ctx.strokeStyle = '#b0a080';
              ctx.lineWidth = 1;
              ctx.strokeRect(x, y, TILE, TILE);
              // Brick accent
              if ((tx + ty) % 4 === 0) {
                ctx.fillStyle = 'rgba(160,120,80,0.15)';
                ctx.fillRect(x + 4, y + 4, TILE - 8, TILE - 8);
              }
            } else {
              // Deli floor — checkered tile pattern
              const checker = (tx + ty) % 2 === 0;
              ctx.fillStyle = checker ? '#e0d8c8' : '#d0c8b0';
              ctx.fillRect(x, y, TILE, TILE);
              ctx.strokeStyle = 'rgba(0,0,0,0.05)';
              ctx.lineWidth = 1;
              ctx.strokeRect(x, y, TILE, TILE);
            }
            continue;
          }

          // === DUNGEON TILES ===

          if (collisionGrid[ty][tx] === 1) {
            if (isBorder) {
              // Outer wall — dark concrete
              ctx.fillStyle = '#2a2a32';
              ctx.fillRect(x, y, TILE, TILE);
              ctx.strokeStyle = '#222230';
              ctx.lineWidth = 1;
              ctx.strokeRect(x, y, TILE, TILE);
            } else {
              // Interior cover block — dark stone bricks
              ctx.fillStyle = '#3a3a44';
              ctx.fillRect(x, y, TILE, TILE);
              // Brick pattern
              ctx.strokeStyle = '#2e2e38';
              ctx.lineWidth = 1;
              const bh = TILE / 2;
              const off = ty % 2 === 0 ? 0 : TILE / 3;
              ctx.strokeRect(x + off, y, TILE/2, bh);
              ctx.strokeRect(x + off - TILE/2, y, TILE/2, bh);
              ctx.strokeRect(x, y + bh, TILE/2, bh);
              ctx.strokeRect(x + TILE/2, y + bh, TILE/2, bh);
              // Top highlight
              ctx.fillStyle = '#454552';
              ctx.fillRect(x, y, TILE, 2);
              // Bottom shadow
              ctx.fillStyle = '#28283a';
              ctx.fillRect(x, y + TILE - 2, TILE, 2);
            }
          } else {
            // Floor tile — lighter toward center
            const cx = level.widthTiles / 2, cy = level.heightTiles / 2;
            const distFromCenter = Math.sqrt((tx - cx) ** 2 + (ty - cy) ** 2);
            const maxDist = 20;
            const centerFade = Math.max(0, 1 - distFromCenter / maxDist);
            const baseR = 58 + Math.round(centerFade * 25);
            const baseG = 55 + Math.round(centerFade * 20);
            const baseB = 55 + Math.round(centerFade * 15);
            const gv = ((tx + ty) % 2 === 0) ? 0 : 2;
            ctx.fillStyle = `rgb(${baseR+gv},${baseG+gv},${baseB+gv})`;
            ctx.fillRect(x, y, TILE, TILE);
            // Subtle grid lines
            ctx.strokeStyle = 'rgba(0,0,0,0.07)';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, TILE, TILE);

            // Blood splatters near center
            if (centerFade > 0.5 && (tx * 13 + ty * 7) % 19 === 0) {
              ctx.fillStyle = `rgba(120,20,20,${0.15 + centerFade * 0.15})`;
              ctx.beginPath();
              ctx.arc(x + TILE*0.4, y + TILE*0.5, 5 + (tx%3)*2, 0, Math.PI*2);
              ctx.fill();
            }
          }
        }
      }
    }

    // _pathRenderer, ENTITY_RENDERERS, drawLevelEntities → js/client/rendering/entityRenderers.js


    // Initialize level
    setLevel(LEVELS.lobby_01);

    // player, keysDown → js/authority/gameState.js

  </script>

  <!-- Phase B: Authority systems (continued) -->
  <script src="js/authority/waveSystem.js"></script>
  <script src="js/authority/damageSystem.js"></script>
  <script src="js/authority/inventorySystem.js"></script>
  <script src="js/authority/stateReset.js"></script>
  <script src="js/authority/miningSystem.js"></script>
  <script src="js/authority/snapshots.js"></script>
  <script src="js/authority/commands.js"></script>
  <script src="js/authority/authorityTick.js"></script>

  <!-- Phase C: Client rendering (continued) -->
  <script src="js/client/rendering/characterSprite.js"></script>

  <!-- Phase D: Client UI -->
  <script src="js/client/input/inputIntent.js"></script>
  <script src="js/client/ui/panelManager.js"></script>
  <script src="js/client/ui/chatProfile.js"></script>
  <script src="js/client/ui/toolbox.js"></script>
  <script src="js/client/ui/settings.js"></script>
  <script src="js/client/ui/panels.js"></script>
  <script src="js/client/ui/customize.js"></script>
  <script src="js/client/ui/inventory.js"></script>

  <!-- Phase E: Input + Core -->
  <script src="js/client/input/input.js"></script>
  <script src="js/core/gunSystem.js"></script>
  <script src="js/core/meleeSystem.js"></script>
  <script src="js/core/saveLoad.js"></script>
  <script src="js/core/interactable.js"></script>
  <script src="js/authority/cookingSystem.js"></script>
  <script src="js/authority/deliNPCSystem.js"></script>
  <script src="js/core/draw.js"></script>
</body>
</html>
